// src/infrastructure/repositories/UserRepositoryImpl.ts
import { ICustomerRepository } from "../../../domain/repositories/ICustomerRepository";
import { User } from "../../../domain/models/User";
import { UserModel } from "../../../infrastructure/database/models/UserModel";
import { IService } from "../../../domain/models/Iservices";
import { IServiceSubcategories } from "../../../domain/models/IServiceSubcategories";
import { SubcategoryModel } from "../models/SubcategoryModel";
import { ServiceModel } from "../../../infrastructure/database/models/ServiceModel";
import { GroupedProviderService } from "../../../domain/models/GroupProviderServices";
import { ProviderServicesModel } from "../models/ProviderServicesModel";
import { StaffServicesModel } from "../models/StaffServicesModel";
import mongoose, { Types } from "mongoose";
import { AddressModel } from "../models/AddressModel";

export class CustomerRepositoryImpl implements ICustomerRepository {
  async getAllCustomers(page: number = 1, limit: number = 3): Promise<User[]> {
    const skip = (page - 1) * limit;
    const customers = await UserModel.find({ role: "customer" })
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit)
      .lean();
    return this.mapUsers(customers);
  }

  async getAllProviders(page: number = 1, limit: number = 3): Promise<User[]> {
    const skip = (page - 1) * limit;
    const providers = await UserModel.find({
      role: { $in: ["provider", "worker"] },
    })
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit)
      .lean();

    return this.mapUsers(providers);
  }

  private mapUsers(users: any[]): User[] {
    return users.map(
      (user): User => ({
        _id: user._id?.toString(),
        fullname: user.fullname ?? undefined,
        companyName: user.companyName ?? undefined,
        username: user.username,
        email: user.email,
        phone: user.phone,
        password: user.password,
        role: user.role,
        providerId: user.providerId?.toString() ?? undefined,
        status: user.status,
        authProvider: user.authProvider,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt,
        image: user.image,
      })
    );
  }

  async adminServices(
    type: string,
    serviceId?: string
  ): Promise<IService[] | IServiceSubcategories[]> {
    if (type === "service") {
      return await ServiceModel.find({ status: "Active" })
        .sort({ createdAt: -1 })
        .lean();
    } else if (type === "subcatgory" && serviceId) {
      return await SubcategoryModel.find({
        serviceId,
        status: "Active",
      }).lean();
    } else {
      throw new Error("Invalid type or missing service ID");
    }
  }

  async providerServiceInLocation(
    mainServiceId:string,
    serviceId: string,
    coordinates?: { lat: number; lng: number }
  ): Promise<GroupedProviderService[] | null> {
    try {
      if(serviceId){
      if (!mongoose.Types.ObjectId.isValid(serviceId)) {
        throw new Error("Invalid serviceId");
      }
    }
      const pipeline: any[] = [];

      // 1. Geo filter on addresses

if (coordinates) {
  pipeline.push({
    $geoNear: {
      near: {
        type: "Point",
        coordinates: [coordinates.lng, coordinates.lat],
      },
      distanceField: "distance",
      spherical: true,
      key: "geoLocation", // Make sure this exists on addresses
      query: {
        status: "Active",
        current: true,
      },
      distanceMultiplier: 0.001,
      maxDistance: 20000, // 20 km in meters
    },
  });
}

// Lookup provider services of this user
pipeline.push(
  {
    $lookup: {
      from: "providerservices",
      localField: "createdBy",
      foreignField: "createdBy",
      as: "providerServices",
    },
  },
  { $unwind: "$providerServices" },
);
 if (serviceId && mongoose.Types.ObjectId.isValid(serviceId)) {
      pipeline.push({
        $match: {
          "providerServices.subcategoryId": new mongoose.Types.ObjectId(serviceId),
        },
      });
    } else if (mainServiceId && mongoose.Types.ObjectId.isValid(mainServiceId)) {
      pipeline.push({
        $match: {
          "providerServices.serviceId": new mongoose.Types.ObjectId(mainServiceId),
        },
      });
    }
     pipeline.push(
      {
        $lookup: {
          from: "users",
          localField: "createdBy",
          foreignField: "_id",
          as: "userDetails",
        },
      },
      { $unwind: "$userDetails" },
      {
        $lookup: {
          from: "subcategories",
          localField: "providerServices.subcategoryId",
          foreignField: "_id",
          as: "subcategoryDetails",
        },
      },
      { $unwind: "$subcategoryDetails" },
      {
        $lookup: {
          from: "services",
          localField: "providerServices.serviceId",
          foreignField: "_id",
          as: "serviceDetails",
        },
      },
      { $unwind: "$serviceDetails" },
      {
        $project: {
          _id: 0,
          fullname: "$userDetails.fullname",
          providerId: "$userDetails._id",
          phone: "$userDetails.phone",
          image: "$userDetails.image",
          description: "$providerServices.description",
          features: "$providerServices.features",
          serviceName: "$serviceDetails.serviceName",
          subcategoryName: "$subcategoryDetails.subcategory",
          distance: 1,
        },
      }
    );




      const results = await AddressModel.aggregate(pipeline);
      
      return results;
    } catch (err: any) {
      console.error(
        "Error getting provider services in location:",
        err.message
      );
      throw err;
    }
  }

  //  async providerServiceInLocation(
  //     serviceId: string,coordinates?:{
  //     lat: number;
  //     lng: number;
  //   }
  //   ): Promise<GroupedProviderService[] | null> {
  //     try {
  //       const results = await ProviderServicesModel.aggregate([
  //         { $match: { serviceId: new mongoose.Types.ObjectId(serviceId) } },
  //         {
  //           $lookup: {
  //             from: "services", // collection name
  //             localField: "serviceId",
  //             foreignField: "_id",
  //             as: "serviceDetails",
  //           },
  //         },
  //         {
  //           $unwind: "$serviceDetails",
  //         },
  //         {
  //           $lookup: {
  //             from: "subcategories",
  //             localField: "subcategoryId",
  //             foreignField: "_id",
  //             as: "subcategoryDetails",
  //           },
  //         },
  //        {
  //   $unwind: {
  //     path: "$subcategoryDetails",
  //     preserveNullAndEmptyArrays: true
  //   }
  // },
  //         {
  //           $group: {
  //             _id: "$serviceDetails._id",
  //             serviceName: { $first: "$serviceDetails.serviceName" },
  //             image: { $first: "$image" },
  //             description: { $first: "$description" },
  //             features: { $first: "$features" },
  //             subcategories: {
  //               $addToSet: {
  //                 _id: "$subcategoryDetails._id",
  //                 name: "$subcategoryDetails.subcategory",
  //               },
  //             },
  //           },
  //         },
  //         {
  //           $project: {
  //             _id: 0,
  //             serviceId: "$_id",
  //             serviceName: 1,
  //             subcategories: 1,
  //           },
  //         },
  //       ]);
  //       return results;
  //     } catch (err: any) {
  //       console.error(" Error saving provider service:", err.message);
  //       throw err;
  //     }
  //   }
  async serviceCategories(
    serviceId?: string
  ): Promise< IServiceSubcategories[]> {
    if (serviceId) {
      return await SubcategoryModel.find({
        serviceId,
        status: "Active",
      }).lean();
    } else {
      throw new Error("Invalid type or missing service ID");
    }
  }
}

